#!/bin/bash

#############################################
# Universal Wayland Theme Applicator v2.0
# Handles repeated execution safely
#############################################

set -e

THEME_FILE="$1"
CONFIG_DIR="$HOME/.config"
BACKUP_DIR="$CONFIG_DIR/theme-backups/$(date +%Y%m%d-%H%M%S)"
MAX_BACKUPS=10  # Keep only last 10 backups

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging functions
log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
log_debug() { echo -e "${BLUE}[DEBUG]${NC} $1"; }

# Validate theme file
if [ -z "$THEME_FILE" ]; then
    log_error "Usage: $0 <theme-file.colortheme>"
    echo "Available themes:"
    ls -1 "$CONFIG_DIR/themes/"*.colortheme 2>/dev/null | xargs -n1 basename || echo "  None found"
    exit 1
fi

if [ ! -f "$THEME_FILE" ]; then
    log_error "Theme file not found: $THEME_FILE"
    exit 1
fi

if [[ ! "$THEME_FILE" =~ \.colortheme$ ]]; then
    log_error "Invalid theme file. Must have .colortheme extension"
    exit 1
fi

log_info "Loading theme: $(basename "$THEME_FILE")"

# Parse theme file
declare -A COLORS
while IFS='=' read -r key value; do
    [[ "$key" =~ ^[[:space:]]*# ]] && continue
    [[ -z "$key" ]] && continue
    [[ "$key" =~ ^\[.*\]$ ]] && continue
    key=$(echo "$key" | xargs)
    value=$(echo "$value" | xargs | tr -d '#')
    COLORS["$key"]="$value"
done < "$THEME_FILE"

# Create backup directory
mkdir -p "$BACKUP_DIR"
log_info "Backups: $BACKUP_DIR"

# Cleanup old backups (keep last N)
cleanup_backups() {
    local backup_root="$CONFIG_DIR/theme-backups"
    local backup_count=$(ls -1d "$backup_root"/*/ 2>/dev/null | wc -l)
    
    if [ "$backup_count" -gt "$MAX_BACKUPS" ]; then
        log_debug "Cleaning old backups (keeping last $MAX_BACKUPS)..."
        ls -1td "$backup_root"/*/ | tail -n +$((MAX_BACKUPS + 1)) | xargs rm -rf
    fi
}

# Safe backup function
backup_file() {
    local file="$1"
    local name="$2"
    
    if [ -f "$file" ]; then
        cp "$file" "$BACKUP_DIR/$name"
        log_debug "Backed up: $name"
    fi
}

# Remove content between markers
remove_auto_section() {
    local file="$1"
    local begin_marker="$2"
    local end_marker="$3"
    
    if [ -f "$file" ]; then
        sed -i "/$begin_marker/,/$end_marker/d" "$file"
    fi
}

# Ensure line exists in file (idempotent)
ensure_line() {
    local file="$1"
    local line="$2"
    local position="${3:-end}"  # 'start' or 'end'
    
    if [ ! -f "$file" ]; then
        echo "$line" > "$file"
        return
    fi
    
    if ! grep -qF "$line" "$file"; then
        if [ "$position" = "start" ]; then
            sed -i "1i $line" "$file"
        else
            echo "$line" >> "$file"
        fi
    fi
}

# Replace or add line with pattern
replace_or_add() {
    local file="$1"
    local pattern="$2"
    local replacement="$3"
    
    if [ ! -f "$file" ]; then
        echo "$replacement" > "$file"
        return
    fi
    
    if grep -q "^${pattern%%=*}" "$file"; then
        sed -i "s|^${pattern%%=*}.*|$replacement|" "$file"
    else
        echo "$replacement" >> "$file"
    fi
}

#############################################
# Application-specific theme functions
#############################################

apply_foot() {
    log_info "Applying theme to foot..."
    
    local foot_config="$CONFIG_DIR/foot/foot.ini"
    local foot_colors="$CONFIG_DIR/foot/colors.ini"
    
    mkdir -p "$CONFIG_DIR/foot"
    backup_file "$foot_colors" "foot-colors.ini"
    
    # Completely replace colors.ini (idempotent)
    cat > "$foot_colors" << EOF
# Auto-generated by apply-theme
# Source: $(basename "$THEME_FILE")
# Generated: $(date)

[colors]
foreground=${COLORS[foreground]}
background=${COLORS[background]}

cursor=${COLORS[cursor]}
cursor-text=${COLORS[cursor-text]}

selection-foreground=${COLORS[selection-fg]}
selection-background=${COLORS[selection-bg]}

# ANSI colors
color0=${COLORS[color0]}
color1=${COLORS[color1]}
color2=${COLORS[color2]}
color3=${COLORS[color3]}
color4=${COLORS[color4]}
color5=${COLORS[color5]}
color6=${COLORS[color6]}
color7=${COLORS[color7]}
color8=${COLORS[color8]}
color9=${COLORS[color9]}
color10=${COLORS[color10]}
color11=${COLORS[color11]}
color12=${COLORS[color12]}
color13=${COLORS[color13]}
color14=${COLORS[color14]}
color15=${COLORS[color15]}
EOF

    # Ensure include directive exists
    if [ ! -f "$foot_config" ]; then
        cat > "$foot_config" << EOF
include=~/.config/foot/colors.ini

[main]
font=FiraCode:size=11
EOF
    else
        ensure_line "$foot_config" "include=~/.config/foot/colors.ini" "start"
    fi
    
    log_info "✓ foot"
}

apply_btop() {
    log_info "Applying theme to btop..."
    
    local btop_config="$CONFIG_DIR/btop/btop.conf"
    local btop_theme="$CONFIG_DIR/btop/themes/autotheme.theme"
    
    mkdir -p "$CONFIG_DIR/btop/themes"
    backup_file "$btop_theme" "btop-theme"
    
    # Completely replace theme file
    cat > "$btop_theme" << EOF
# Btop theme auto-generated by apply-theme
# Source: $(basename "$THEME_FILE")
# Generated: $(date)

theme[main_bg]="#${COLORS[background]}"
theme[main_fg]="#${COLORS[foreground]}"
theme[title]="#${COLORS[blue]}"
theme[hi_fg]="#${COLORS[cyan]}"
theme[selected_bg]="#${COLORS[selection-bg]}"
theme[selected_fg]="#${COLORS[selection-fg]}"
theme[inactive_fg]="#${COLORS[comment]}"
theme[proc_misc]="#${COLORS[purple]}"
theme[cpu_box]="#${COLORS[blue]}"
theme[mem_box]="#${COLORS[green]}"
theme[net_box]="#${COLORS[cyan]}"
theme[proc_box]="#${COLORS[yellow]}"
theme[div_line]="#${COLORS[border]}"
theme[temp_start]="#${COLORS[green]}"
theme[temp_mid]="#${COLORS[yellow]}"
theme[temp_end]="#${COLORS[red]}"
theme[cpu_start]="#${COLORS[green]}"
theme[cpu_mid]="#${COLORS[yellow]}"
theme[cpu_end]="#${COLORS[red]}"
theme[free_start]="#${COLORS[green]}"
theme[free_mid]="#${COLORS[yellow]}"
theme[free_end]="#${COLORS[red]}"
theme[cached_start]="#${COLORS[cyan]}"
theme[cached_mid]="#${COLORS[blue]}"
theme[cached_end]="#${COLORS[purple]}"
theme[available_start]="#${COLORS[green]}"
theme[available_mid]="#${COLORS[yellow]}"
theme[available_end]="#${COLORS[red]}"
theme[used_start]="#${COLORS[green]}"
theme[used_mid]="#${COLORS[yellow]}"
theme[used_end]="#${COLORS[red]}"
theme[download_start]="#${COLORS[green]}"
theme[download_mid]="#${COLORS[cyan]}"
theme[download_end]="#${COLORS[blue]}"
theme[upload_start]="#${COLORS[yellow]}"
theme[upload_mid]="#${COLORS[orange]}"
theme[upload_end]="#${COLORS[red]}"
theme[process_start]="#${COLORS[green]}"
theme[process_mid]="#${COLORS[yellow]}"
theme[process_end]="#${COLORS[red]}"
EOF

    # Update btop.conf (idempotent)
    if [ -f "$btop_config" ]; then
        backup_file "$btop_config" "btop.conf"
        replace_or_add "$btop_config" "color_theme=" 'color_theme="autotheme"'
    else
        echo 'color_theme="autotheme"' > "$btop_config"
    fi
    
    log_info "✓ btop"
}

apply_lf() {
    log_info "Applying theme to lf..."
    
    local lf_config="$CONFIG_DIR/lf/lfrc"
    
    mkdir -p "$CONFIG_DIR/lf"
    backup_file "$lf_config" "lfrc"
    
    # lf inherits terminal colors
    if [ ! -f "$lf_config" ]; then
        touch "$lf_config"
    fi
    
    log_info "✓ lf (uses terminal colors)"
}

apply_niri() {
    log_info "Applying theme to niri..."
    
    local niri_config="$CONFIG_DIR/niri/config.kdl"
    
    mkdir -p "$CONFIG_DIR/niri"
    backup_file "$niri_config" "niri-config.kdl"
    
    # Remove old auto-generated section
    if [ -f "$niri_config" ]; then
        remove_auto_section "$niri_config" "// BEGIN AUTO-THEME" "// END AUTO-THEME"
    else
        touch "$niri_config"
    fi
    
    # Append new theme
    cat >> "$niri_config" << EOF

// BEGIN AUTO-THEME - Auto-generated, do not edit
// Source: $(basename "$THEME_FILE")
// Generated: $(date)

prefer-no-csd

border {
    width 2
    active-color "#${COLORS[active-border]}"
    inactive-color "#${COLORS[inactive-border]}"
}

layout {
    focus-ring {
        width 2
        active-color "#${COLORS[active-border]}"
        inactive-color "#${COLORS[inactive-border]}"
    }
}

// END AUTO-THEME
EOF
    
    log_info "✓ niri"
}

apply_waylock() {
    log_info "Applying theme to waylock..."
    
    local waylock_wrapper="$HOME/.local/bin/waylock-themed"
    
    backup_file "$waylock_wrapper" "waylock-themed"
    mkdir -p "$HOME/.local/bin"
    
    # Completely replace wrapper
    cat > "$waylock_wrapper" << EOF
#!/bin/bash
# Auto-generated waylock wrapper
# Source: $(basename "$THEME_FILE")
# Generated: $(date)

exec waylock \\
    -init-color 0x${COLORS[background]} \\
    -input-color 0x${COLORS[blue]} \\
    -fail-color 0x${COLORS[red]} \\
    "\$@"
EOF
    chmod +x "$waylock_wrapper"
    
    log_info "✓ waylock (use: waylock-themed)"
}

apply_tuigreet() {
    log_info "Applying theme to tuigreet..."
    log_info "✓ tuigreet (inherits foot colors)"
}

apply_mako() {
    log_info "Applying theme to mako..."
    
    local mako_config="$CONFIG_DIR/mako/config"
    
    mkdir -p "$CONFIG_DIR/mako"
    backup_file "$mako_config" "mako-config"
    
    # Remove old section
    if [ -f "$mako_config" ]; then
        remove_auto_section "$mako_config" "# BEGIN AUTO-THEME" "# END AUTO-THEME"
    else
        touch "$mako_config"
    fi
    
    # Append new theme
    cat >> "$mako_config" << EOF

# BEGIN AUTO-THEME - Auto-generated, do not edit
# Source: $(basename "$THEME_FILE")
# Generated: $(date)

background-color=#${COLORS[background]}
text-color=#${COLORS[foreground]}
border-color=#${COLORS[border]}
border-size=2
border-radius=8

[urgency=low]
border-color=#${COLORS[info]}

[urgency=normal]
border-color=#${COLORS[blue]}

[urgency=high]
border-color=#${COLORS[error]}

# END AUTO-THEME
EOF

    # Reload mako
    if pgrep -x mako > /dev/null; then
        makoctl reload 2>/dev/null && log_debug "Reloaded mako"
    fi
    
    log_info "✓ mako"
}

apply_mpv() {
    log_info "Applying theme to mpv..."
    
    local mpv_config="$CONFIG_DIR/mpv/mpv.conf"
    
    mkdir -p "$CONFIG_DIR/mpv"
    backup_file "$mpv_config" "mpv.conf"
    
    # Remove old section
    if [ -f "$mpv_config" ]; then
        remove_auto_section "$mpv_config" "# BEGIN AUTO-THEME" "# END AUTO-THEME"
    else
        touch "$mpv_config"
    fi
    
    # Append new theme
    cat >> "$mpv_config" << EOF

# BEGIN AUTO-THEME - Auto-generated, do not edit
# Source: $(basename "$THEME_FILE")
# Generated: $(date)

osd-color='#${COLORS[foreground]}'
osd-border-color='#${COLORS[background]}'
osd-back-color='#${COLORS[background-alt]}'
osd-shadow-color='#${COLORS[background]}'

# END AUTO-THEME
EOF
    
    log_info "✓ mpv"
}

apply_neovim() {
    log_info "Applying theme to neovim..."
    
    local nvim_colors="$CONFIG_DIR/nvim/colors/autotheme.lua"
    local nvim_init_lua="$CONFIG_DIR/nvim/init.lua"
    
    mkdir -p "$CONFIG_DIR/nvim/colors"
    backup_file "$nvim_colors" "autotheme.lua"
    
    # Completely replace colorscheme
    cat > "$nvim_colors" << EOF
-- Auto-generated neovim colorscheme
-- Source: $(basename "$THEME_FILE")
-- Generated: $(date)
-- Usage: :colorscheme autotheme

vim.cmd('highlight clear')
if vim.fn.exists('syntax_on') then
  vim.cmd('syntax reset')
end

vim.g.colors_name = 'autotheme'
vim.o.background = 'dark'

local colors = {
  bg = '#${COLORS[background]}',
  fg = '#${COLORS[foreground]}',
  bg_alt = '#${COLORS[background-alt]}',
  comment = '#${COLORS[comment]}',
  red = '#${COLORS[red]}',
  orange = '#${COLORS[orange]}',
  yellow = '#${COLORS[yellow]}',
  green = '#${COLORS[green]}',
  cyan = '#${COLORS[cyan]}',
  blue = '#${COLORS[blue]}',
  purple = '#${COLORS[purple]}',
  selection = '#${COLORS[selection-bg]}',
  border = '#${COLORS[border]}',
}

local function hl(group, opts)
  vim.api.nvim_set_hl(0, group, opts)
end

-- Editor
hl('Normal', { fg = colors.fg, bg = colors.bg })
hl('NormalFloat', { fg = colors.fg, bg = colors.bg_alt })
hl('Comment', { fg = colors.comment, italic = true })
hl('Constant', { fg = colors.orange })
hl('String', { fg = colors.green })
hl('Character', { fg = colors.green })
hl('Number', { fg = colors.orange })
hl('Boolean', { fg = colors.orange })
hl('Float', { fg = colors.orange })
hl('Identifier', { fg = colors.red })
hl('Function', { fg = colors.blue })
hl('Statement', { fg = colors.purple })
hl('Conditional', { fg = colors.purple })
hl('Repeat', { fg = colors.purple })
hl('Label', { fg = colors.purple })
hl('Operator', { fg = colors.cyan })
hl('Keyword', { fg = colors.red })
hl('Exception', { fg = colors.purple })
hl('PreProc', { fg = colors.yellow })
hl('Type', { fg = colors.yellow })
hl('Special', { fg = colors.cyan })
hl('Delimiter', { fg = colors.fg })

-- UI
hl('Cursor', { fg = colors.bg, bg = colors.fg })
hl('Visual', { bg = colors.selection })
hl('CursorLine', { bg = colors.bg_alt })
hl('CursorColumn', { bg = colors.bg_alt })
hl('LineNr', { fg = colors.comment })
hl('CursorLineNr', { fg = colors.yellow })
hl('VertSplit', { fg = colors.border })
hl('StatusLine', { fg = colors.fg, bg = colors.bg_alt })
hl('StatusLineNC', { fg = colors.comment, bg = colors.bg_alt })
hl('Pmenu', { fg = colors.fg, bg = colors.bg_alt })
hl('PmenuSel', { fg = colors.bg, bg = colors.blue })
hl('Search', { fg = colors.bg, bg = colors.yellow })
hl('IncSearch', { fg = colors.bg, bg = colors.orange })

-- Git
hl('DiffAdd', { fg = colors.green })
hl('DiffChange', { fg = colors.yellow })
hl('DiffDelete', { fg = colors.red })
hl('DiffText', { fg = colors.blue })

-- Diagnostics
hl('DiagnosticError', { fg = colors.red })
hl('DiagnosticWarn', { fg = colors.yellow })
hl('DiagnosticInfo', { fg = colors.blue })
hl('DiagnosticHint', { fg = colors.cyan })
EOF

    # Ensure colorscheme is set in init.lua
    if [ -f "$nvim_init_lua" ]; then
        if ! grep -q "colorscheme autotheme" "$nvim_init_lua"; then
            backup_file "$nvim_init_lua" "init.lua"
            echo "" >> "$nvim_init_lua"
            echo "-- Auto-set theme" >> "$nvim_init_lua"
            echo "vim.cmd('colorscheme autotheme')" >> "$nvim_init_lua"
        fi
    fi
    
    log_info "✓ neovim"
}

apply_bluetuith() {
    log_info "✓ bluetuith (uses terminal colors)"
}

apply_impala() {
    log_info "✓ impala (uses terminal colors)"
}

apply_fonts() {
    log_info "Setting FiraCode font..."
    
    # Update foot font (idempotent)
    local foot_config="$CONFIG_DIR/foot/foot.ini"
    if [ -f "$foot_config" ]; then
        backup_file "$foot_config" "foot.ini"
        replace_or_add "$foot_config" "font=" "font=FiraCode:size=11"
    fi
    
    log_info "✓ FiraCode font"
}

#############################################
# Main execution
#############################################

log_info "Starting theme application..."
echo ""

# Apply to all applications
apply_foot
apply_btop
apply_lf
apply_niri
apply_waylock
apply_tuigreet
apply_mako
apply_mpv
apply_neovim
apply_bluetuith
apply_impala
apply_fonts

# Cleanup old backups
cleanup_backups

echo ""
log_info "✓ Theme applied: $(basename "$THEME_FILE")"
log_info "Backups: $BACKUP_DIR"
echo ""
log_info "Reload applications:"
echo "  foot      → Open new terminal"
echo "  btop      → Press 'R' in btop"
echo "  niri      → niri msg action quit"
echo "  mako      → Auto-reloaded"
echo "  neovim    → :colorscheme autotheme"
echo "  waylock   → Use: waylock-themed"