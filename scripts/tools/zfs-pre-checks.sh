#!/bin/bash
# filepath: zfs-pre-checks.sh
# ZFS Pre-Update Checks for Void Linux with ZFSBootMenu Support
# This script checks for updates FIRST, then performs comprehensive system checks

set -euo pipefail

# Configuration
LOG_FILE="/var/log/zfs-pre-checks-$(date +%Y%m%d-%H%M%S).log"
BACKUP_DIR="/var/backups/zfs-update-$(date +%Y%m%d-%H%M%S)"
CONFIG_FILE="/etc/zfs-update.conf"
ZBM_CONFIG="/etc/zfsbootmenu/config.yaml"

# Global variables for cross-function use
ZBM_DETECTED=false
TOTAL_UPDATES=0
ZFS_COUNT=0
ZBM_COUNT=0
DRACUT_COUNT=0
KERNEL_COUNT=0
FIRMWARE_COUNT=0
ESP_MOUNT=""
ZBM_EFI_PATH=""

# Colors for output 
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;94m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

log() {
    echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

success() {
    log "${GREEN}✓ $1${NC}"
}

warning() {
    log "${YELLOW}⚠ WARNING: $1${NC}"
}

error() {
    log "${RED}✗ ERROR: $1${NC}"
}

info() {
    log "${BLUE}ℹ INFO: $1${NC}"
}

header() {
    echo ""
    log "${BOLD}${CYAN}=========================================="
    log "$1"
    log "==========================================${NC}"
    echo ""
}

error_exit() {
    error "$1"
    log "Pre-checks failed. Fix issues before proceeding with updates."
    exit 1
}

check_root() {
    if [ "$EUID" -ne 0 ]; then
        error_exit "This script must be run as root"
    fi
}

validate_dependencies() {
    info "Validating system dependencies..."
    local deps="xbps-install zpool zfs findmnt df grep awk sed mkdir cp bc"
    local missing_deps=""
    local cmd
    
    for cmd in $deps; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing_deps="$missing_deps $cmd"
        fi
    done
    
    if [ -n "$missing_deps" ]; then
        error_exit "Required commands not found:$missing_deps"
    fi
    
    success "All required dependencies available"
}

create_initial_config() {
    cat > "$CONFIG_FILE" << EOF
#!/bin/bash
# ZFS Update Configuration
# Generated by zfs-pre-checks.sh on $(date)
# This file can be sourced by other scripts

# Basic configuration
BACKUP_DIR="$BACKUP_DIR"
LOG_FILE="$LOG_FILE"
TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
SCRIPT_VERSION="1.2"
VOID_LINUX=true

# System detection
ARCH="$(uname -m)"
KERNEL_VERSION="$(uname -r)"
HOSTNAME="$(hostname)"

# Will be populated by checks
UPDATES_AVAILABLE=false
ZFSBOOTMENU=false
POOLS_EXIST=false
EOF
    chmod 600 "$CONFIG_FILE"
}

check_available_updates() {
    header "CHECKING FOR AVAILABLE UPDATES"
    
    info "Syncing package database..."
    if ! xbps-install -S; then
        error_exit "Failed to sync package database. Check network connection."
    fi
    success "Package database synced"
    
    # Capture output then grep - FIXED SIGPIPE
    local all_updates
    all_updates=$(xbps-install -un 2>/dev/null || true)
    
    # Check for ZFS-specific updates (more precise matching)
    local zfs_updates zfs_count
    zfs_updates=$(echo "$all_updates" | grep -E "^zfs-[0-9]" || true)
    zfs_count=$(echo "$zfs_updates" | grep -c "^zfs-" 2>/dev/null || echo "0")
    
    # Check for ZFSBootMenu updates - try multiple patterns
    local zbm_updates zbm_count
    zbm_updates=$(echo "$all_updates" | grep -E "^zfsbootmenu " || true)
    if [ -n "$zbm_updates" ]; then
        zbm_count=$(echo "$zbm_updates" | wc -l)
    else
        zbm_count=0
    fi
    
    # Check for dracut updates
    local dracut_updates dracut_count
    dracut_updates=$(echo "$all_updates" | grep -E "^dracut-[0-9]" || true)
    dracut_count=$(echo "$dracut_updates" | grep -c "^dracut-" 2>/dev/null || echo "0")
    
    # Check for kernel updates (Void uses linux<version> packages)
    local kernel_updates kernel_count
    kernel_updates=$(echo "$all_updates" | grep -E "^linux[0-9]+\.[0-9]+-[0-9]" || true)
    kernel_count=$(echo "$kernel_updates" | grep -c -E "^linux[0-9]+\.[0-9]+" 2>/dev/null || echo "0")
    
    # Check for firmware updates
    local firmware_updates firmware_count
    firmware_updates=$(echo "$all_updates" | grep -E "^linux-firmware-[0-9]" || true)
    firmware_count=$(echo "$firmware_updates" | grep -c "^linux-firmware-" 2>/dev/null || echo "0")
    
    # Calculate total relevant updates
    local total_updates=$((zfs_count + zbm_count + dracut_count + kernel_count + firmware_count))
    
    if [ "$total_updates" -eq 0 ]; then
        header "NO UPDATES AVAILABLE"
        success "System is up to date for ZFS-related packages"
        info "You can run 'xbps-install -u' to check for other package updates"
        
        # Create minimal config for consistency
        {
            echo "UPDATES_AVAILABLE=false"
            echo "TOTAL_UPDATES=0"
            echo "ZFS_COUNT=0"
            echo "ZBM_COUNT=0"
            echo "DRACUT_COUNT=0"
            echo "KERNEL_COUNT=0"
            echo "FIRMWARE_COUNT=0"
        } >> "$CONFIG_FILE"
        
        return 1  # No updates needed
    else
        success "Found $total_updates ZFS/kernel/firmware/dracut updates"
        
        # Save update information to config
        {
            echo "UPDATES_AVAILABLE=true"
            echo "TOTAL_UPDATES=$total_updates"
            echo "ZFS_COUNT=$zfs_count"
            echo "ZBM_COUNT=$zbm_count"
            echo "DRACUT_COUNT=$dracut_count"
            echo "KERNEL_COUNT=$kernel_count"
            echo "FIRMWARE_COUNT=$firmware_count"
        } >> "$CONFIG_FILE"
        
        # Export for use in main function summary
        TOTAL_UPDATES=$total_updates
        ZFS_COUNT=$zfs_count
        ZBM_COUNT=$zbm_count
        DRACUT_COUNT=$dracut_count
        KERNEL_COUNT=$kernel_count
        FIRMWARE_COUNT=$firmware_count
        
        return 0  # Updates available
    fi
}

check_zfs_loaded() {
    info "Checking ZFS module status..."
    
    # Capture lsmod output then grep - FIXED SIGPIPE
    local lsmod_output
    lsmod_output=$(lsmod)
    if ! echo "$lsmod_output" | grep -q zfs; then
        error_exit "ZFS module is not loaded. Load it with: modprobe zfs"
    fi
    
    if ! command -v zpool >/dev/null 2>&1; then
        error_exit "ZFS userland tools not found. Install zfs package."
    fi
    
    if ! command -v zfs >/dev/null 2>&1; then
        error_exit "ZFS userland tools not found. Install zfs package."
    fi
    
    success "ZFS module and tools are available"
}

check_dracut_available() {
    info "Checking dracut availability..."
    
    if ! command -v dracut >/dev/null 2>&1; then
        error_exit "dracut command not found. Install dracut package."
    fi
    
    # Check dracut configuration
    if [ ! -f /etc/dracut.conf ] && [ ! -d /etc/dracut.conf.d ]; then
        warning "No dracut configuration found. Default settings will be used."
    fi
    
    # Check for ZFS dracut module in common locations
    local dracut_zfs_found=false
    local dracut_module_dirs="/usr/lib/dracut/modules.d /usr/share/dracut/modules.d"
    local module_dir
    
    for module_dir in $dracut_module_dirs; do
        if [ -d "$module_dir/90zfs" ]; then
            dracut_zfs_found=true
            info "Found ZFS dracut module in $module_dir"
            break
        fi
    done
    
    if [ "$dracut_zfs_found" = false ]; then
        error_exit "dracut ZFS support not available. Install zfs package."
    fi
    
    success "dracut is available with ZFS support"
}

check_void_services() {
    info "Checking Void Linux specific services..."
    
    # Check if any services are using ZFS datasets
    if command -v sv >/dev/null 2>&1; then
        # Capture sv output then grep - FIXED SIGPIPE
        local sv_status active_services service service_name
        sv_status=$(sv status /var/service/* 2>/dev/null || true)
        active_services=$(echo "$sv_status" | grep "^run:" | awk '{print $2}' || true)
        
        for service in $active_services; do
            service_name=$(basename "$service")
            if [ "$service_name" = "sshd" ] || [ "$service_name" = "chronyd" ] || [ "$service_name" = "dbus" ]; then
                # These are typically safe to keep running
                continue
            fi
            log "Active service detected: $service_name"
        done
    fi
    
    success "Void services check completed"
}

check_zfs_specific_updates() {
    info "Checking ZFS-specific package updates..."
    
    local zfs_packages="zfs zfsbootmenu dracut"
    local zfs_specific_updates=""
    local zfs_specific_count=0
    local pkg
    
    # Capture xbps output then grep - FIXED SIGPIPE
    local xbps_updates
    xbps_updates=$(xbps-install -un 2>/dev/null || true)
    
    for pkg in $zfs_packages; do
        if echo "$xbps_updates" | grep -q "^${pkg}-"; then
            zfs_specific_updates="$zfs_specific_updates $pkg"
            zfs_specific_count=$((zfs_specific_count + 1))
        fi
    done
    
    if [ -n "$zfs_specific_updates" ]; then
        info "ZFS-related packages with updates:$zfs_specific_updates"
        echo "ZFS_SPECIFIC_UPDATES=\"$zfs_specific_updates\"" >> "$CONFIG_FILE"
        echo "ZFS_SPECIFIC_COUNT=$zfs_specific_count" >> "$CONFIG_FILE"
        return 0
    else
        info "No ZFS-specific package updates found"
        echo "ZFS_SPECIFIC_UPDATES=\"\"" >> "$CONFIG_FILE"
        echo "ZFS_SPECIFIC_COUNT=0" >> "$CONFIG_FILE"
        return 1
    fi
}

detect_zfsbootmenu() {
    info "Detecting boot method..."
    
    local zbm_detected=false
    local zbm_config_paths="/etc/zfsbootmenu/config.yaml /etc/zfsbootmenu.yaml /usr/share/zfsbootmenu/config.yaml"
    local config_path
    
    # Check multiple possible config locations
    for config_path in $zbm_config_paths; do
        if [ -f "$config_path" ]; then
            ZBM_CONFIG="$config_path"
            zbm_detected=true
            info "ZFSBootMenu configuration found: $ZBM_CONFIG"
            break
        fi
    done
    
    if command -v efibootmgr >/dev/null 2>&1; then
        # Capture efibootmgr output then grep - FIXED SIGPIPE
        local efi_output
        efi_output=$(efibootmgr 2>/dev/null || true)
        if echo "$efi_output" | grep -qi "zfsbootmenu\|ZBM"; then
            zbm_detected=true
            info "ZFSBootMenu found in EFI boot entries"
        fi
    fi
    
    if command -v generate-zbm >/dev/null 2>&1; then
        zbm_detected=true
        local zbm_version
        zbm_version=$(generate-zbm --version 2>/dev/null | head -1 || echo "unknown")
        info "ZFSBootMenu tools available, version: $zbm_version"
        echo "ZBM_VERSION=\"$zbm_version\"" >> "$CONFIG_FILE"
    fi
    
    if [ "$zbm_detected" = true ]; then
        success "ZFSBootMenu system detected"
        echo "ZFSBOOTMENU=true" >> "$CONFIG_FILE"
        ZBM_DETECTED=true
    else
        info "Traditional bootloader system"
        echo "ZFSBOOTMENU=false" >> "$CONFIG_FILE"
        ZBM_DETECTED=false
    fi
}

check_system_versions() {
    info "Checking current system versions..."
    
    local current_kernel current_zfs zfs_userland dracut_version
    
    current_kernel=$(uname -r)
    
    # More reliable ZFS version detection
    if command -v zfs >/dev/null 2>&1; then
        # Capture zfs version output - FIXED SIGPIPE
        local zfs_ver_output
        zfs_ver_output=$(zfs version 2>/dev/null || true)
        current_zfs=$(echo "$zfs_ver_output" | grep -E "^zfs-kmod" | awk '{print $2}' || echo "unknown")
        zfs_userland=$(echo "$zfs_ver_output" | grep -E "^zfs-" | head -1 | awk '{print $2}' || echo "unknown")
        
        # Fallback to modinfo if zfs version doesn't work
        if [ "$current_zfs" = "unknown" ]; then
            local modinfo_output
            modinfo_output=$(modinfo zfs 2>/dev/null || true)
            current_zfs=$(echo "$modinfo_output" | grep -E "^version:" | awk '{print $2}' || echo "unknown")
        fi
    else
        current_zfs="unknown"
        zfs_userland="unknown"
    fi
    
    # Get dracut version if available
    dracut_version=$(dracut --version 2>/dev/null | head -1 || echo "unknown")
    
    log "Current kernel: $current_kernel"
    log "ZFS kernel module: $current_zfs"
    log "ZFS userland: $zfs_userland"
    log "Dracut version: $dracut_version"
    
    # Check for version mismatch
    if [ "$current_zfs" != "unknown" ] && [ "$zfs_userland" != "unknown" ] && [ "$current_zfs" != "$zfs_userland" ]; then
        warning "ZFS kernel module ($current_zfs) and userland ($zfs_userland) versions differ"
        warning "This is normal if updates are available"
    else
        success "ZFS kernel and userland versions match"
    fi
    
    # Save version info
    {
        echo "CURRENT_KERNEL=\"$current_kernel\""
        echo "CURRENT_ZFS=\"$current_zfs\""
        echo "ZFS_USERLAND=\"$zfs_userland\""
        echo "DRACUT_VERSION=\"$dracut_version\""
    } >> "$CONFIG_FILE"
}

check_pool_health() {
    info "Checking ZFS pool health..."
    
    if ! zpool list >/dev/null 2>&1; then
        warning "No ZFS pools found"
        echo "POOLS_EXIST=false" >> "$CONFIG_FILE"
        return 0
    fi
    
    echo "POOLS_EXIST=true" >> "$CONFIG_FILE"
    
    info "Current pool status:"
    zpool status -v | tee -a "$LOG_FILE"
    
    # Capture zpool status then grep - FIXED SIGPIPE
    local pool_status
    pool_status=$(zpool status)
    
    if echo "$pool_status" | grep -E "(DEGRADED|FAULTED|OFFLINE|UNAVAIL)"; then
        error_exit "ZFS pools have errors. Fix pool issues before updating."
    fi
    
    if echo "$pool_status" | grep -q "scrub in progress"; then
        error_exit "ZFS scrub is in progress. Wait for completion before updating."
    fi
    
    if echo "$pool_status" | grep -q "resilver in progress"; then
        error_exit "ZFS resilver is in progress. Wait for completion before updating."
    fi
    
    success "All ZFS pools are healthy"
}

check_zbm_boot_pool() {
    if [ "${ZBM_DETECTED}" != "true" ]; then
        return 0
    fi
    
    info "Checking ZFS root pool configuration..."
    
    local boot_pools pool
    
    # Check for root pool (typically 'zroot' based on installation script)
    if zpool list zroot >/dev/null 2>&1; then
        boot_pools="zroot"
    else
        # Fallback to other common names
        local pool_list
        pool_list=$(zpool list -H -o name 2>/dev/null || true)
        boot_pools=$(echo "$pool_list" | grep -E "(bpool|boot|rpool)" || true)
    fi
    
    if [ -z "$boot_pools" ] && [ -f "$ZBM_CONFIG" ]; then
        # Try to detect from ZBM config - FIXED grep
        local zbm_config_content
        zbm_config_content=$(cat "$ZBM_CONFIG" 2>/dev/null || true)
        boot_pools=$(echo "$zbm_config_content" | grep -E "pool:" | grep -v "^#" | awk -F: '{print $2}' | tr -d ' "' || true)
    fi
    
    if [ -n "$boot_pools" ]; then
        info "ZFS pool(s) detected: $boot_pools"
        echo "BOOT_POOLS=\"$boot_pools\"" >> "$CONFIG_FILE"
        
        for pool in $boot_pools; do
            # Capture zpool status then grep - FIXED SIGPIPE
            local pool_status
            pool_status=$(zpool status "$pool" 2>/dev/null || true)
            if ! echo "$pool_status" | grep -q "state: ONLINE"; then
                error_exit "Pool $pool is not ONLINE. Fix before updating."
            fi
        done
        
        success "ZFS pool(s) are healthy"
    else
        warning "No ZFS pools found"
        echo "BOOT_POOLS=\"\"" >> "$CONFIG_FILE"
    fi
}

check_zbm_esp() {
    if [ "${ZBM_DETECTED}" != "true" ]; then
        return 0
    fi
    
    info "Checking EFI System Partition for ZFSBootMenu..."
    
    local esp_candidates="/boot/efi /efi /boot"
    local esp_mount="" esp_path
    
    for esp_path in $esp_candidates; do
        # Capture findmnt output - FIXED SIGPIPE
        local findmnt_output
        findmnt_output=$(findmnt -t vfat "$esp_path" 2>/dev/null || true)
        if [ -n "$findmnt_output" ]; then
            esp_mount="$esp_path"
            break
        fi
    done
    
    if [ -z "$esp_mount" ]; then
        esp_mount=$(findmnt -n -o TARGET -t vfat 2>/dev/null | head -1 || true)
    fi
    
    if [ -z "$esp_mount" ] || [ ! -d "$esp_mount" ]; then
        error_exit "EFI System Partition not found. ZFSBootMenu requires ESP."
    fi
    
    local esp_usage esp_free_mb
    esp_usage=$(df "$esp_mount" | awk 'NR==2 {print $5}' | sed 's/%//' || echo "0")
    esp_free_mb=$(df -m "$esp_mount" | awk 'NR==2 {print $4}' || echo "0")
    
    if [ "$esp_usage" -gt 80 ]; then
        warning "EFI System Partition is ${esp_usage}% full"
    fi
    
    if [ "$esp_free_mb" -lt 50 ]; then
        error_exit "EFI System Partition has less than 50MB free"
    fi
    
    # Check for ZBM files - Match installation script paths: /boot/efi/EFI/ZBM/
    if [ -f "$esp_mount/EFI/ZBM/vmlinuz.efi" ]; then
        local zbm_efi_path="$esp_mount/EFI/ZBM/vmlinuz.efi"
        echo "ZBM_EFI_PATH=\"$zbm_efi_path\"" >> "$CONFIG_FILE"
        ZBM_EFI_PATH="$zbm_efi_path"
        success "ZFSBootMenu EFI image found"
    elif [ -f "$esp_mount/EFI/ZBM/vmlinuz-backup.efi" ]; then
        local zbm_efi_path="$esp_mount/EFI/ZBM/vmlinuz-backup.efi"
        echo "ZBM_EFI_PATH=\"$zbm_efi_path\"" >> "$CONFIG_FILE"
        ZBM_EFI_PATH="$zbm_efi_path"
        info "Only backup ZFSBootMenu EFI image found"
    fi
    
    # Set global variable for other functions
    ESP_MOUNT="$esp_mount"
    
    {
        echo "ESP_MOUNT=\"$esp_mount\""
        echo "ESP_USAGE=$esp_usage"
        echo "ESP_FREE_MB=$esp_free_mb"
    } >> "$CONFIG_FILE"
    
    success "ESP check completed (${esp_usage}% used, ${esp_free_mb}MB free)"
}

check_system_resources() {
    info "Checking system resources..."
    
    local available_mem_kb available_mem_mb load_avg load_check
    
    # Check available memory (ZFS needs sufficient RAM)
    available_mem_kb=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
    available_mem_mb=$((available_mem_kb / 1024))
    
    if [ "$available_mem_mb" -lt 512 ]; then
        warning "Less than 512MB RAM available. ZFS updates may be slow."
    fi
    
    # Check system load
    load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk -F',' '{print $1}' | tr -d ' ')
    load_check=$(echo "$load_avg > 2" | bc 2>/dev/null || echo "0")
    
    if [ "$load_check" = "1" ]; then
        warning "High system load detected: $load_avg"
        warning "Consider waiting for load to decrease"
    fi
    
    success "System resources check completed"
}

check_disk_space() {
    info "Checking disk space..."
    
    local root_usage root_free_mb boot_usage boot_free_mb backup_free_mb
    
    root_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//' || echo "0")
    root_free_mb=$(df -m / | awk 'NR==2 {print $4}' || echo "0")
    
    if [ "$root_usage" -gt 90 ]; then
        error_exit "Root filesystem is ${root_usage}% full. Need space for updates."
    fi
    
    if mountpoint -q /boot 2>/dev/null; then
        boot_usage=$(df /boot | awk 'NR==2 {print $5}' | sed 's/%//' || echo "0")
        boot_free_mb=$(df -m /boot | awk 'NR==2 {print $4}' || echo "0")
        
        if [ "$boot_usage" -gt 80 ]; then
            warning "Boot partition is ${boot_usage}% full"
        fi
        
        if [ "$boot_free_mb" -lt 100 ]; then
            error_exit "Boot partition needs at least 100MB free"
        fi
    fi
    
    backup_free_mb=$(df -m "$(dirname "$BACKUP_DIR")" | awk 'NR==2 {print $4}' || echo "0")
    if [ "$backup_free_mb" -lt 1024 ]; then
        warning "Less than 1GB available for backups"
    fi
    
    success "Sufficient disk space available"
}

check_running_processes() {
    info "Checking for interfering processes..."
    
    # Check for database processes - FIXED pgrep
    if pgrep -f "(mysqld|postgresql|mongodb|mariadb)" >/dev/null 2>&1; then
        warning "Database processes detected - consider stopping before update"
    fi
    
    # Check for backup processes - FIXED pgrep
    if pgrep -f "(rsync|borgbackup|duplicity)" >/dev/null 2>&1; then
        warning "Backup processes detected - consider waiting for completion"
    fi
    
    # Check for package manager processes - FIXED pgrep
    if pgrep -f "xbps-install" >/dev/null 2>&1; then
        error_exit "Another xbps-install process is running. Wait for completion."
    fi
    
    success "Process check completed"
}

create_backups() {
    info "Creating backup directory and configurations..."
    
    mkdir -p "$BACKUP_DIR"
    
    if [ "${POOLS_EXIST:-false}" = "true" ]; then
        info "Backing up ZFS configurations..."
        {
            zfs list -H -o name,mountpoint > "$BACKUP_DIR/zfs-datasets.txt"
            zpool list -H > "$BACKUP_DIR/zpool-list.txt"
            zfs get all > "$BACKUP_DIR/zfs-properties.txt"
            zpool get all > "$BACKUP_DIR/zpool-properties.txt"
            zfs list -t snapshot > "$BACKUP_DIR/zfs-snapshots.txt" 2>/dev/null || true
        } 2>/dev/null || warning "Some ZFS backup commands failed"
    fi
    
    # Backup system configs
    cp /etc/fstab "$BACKUP_DIR/" 2>/dev/null || true
    
    if [ -d /boot/grub ]; then
        cp -r /boot/grub "$BACKUP_DIR/grub-backup/" 2>/dev/null || true
    fi
    
    if [ -f /etc/dracut.conf ]; then
        cp /etc/dracut.conf "$BACKUP_DIR/" 2>/dev/null || true
    fi
    
    if [ -d /etc/dracut.conf.d ]; then
        cp -r /etc/dracut.conf.d "$BACKUP_DIR/" 2>/dev/null || true
    fi
    
    # Backup modprobe configs that might affect ZFS
    if [ -d /etc/modprobe.d ]; then
        cp /etc/modprobe.d/*.conf "$BACKUP_DIR/" 2>/dev/null || true
    fi
    
    success "System configuration backup created"
}

backup_zbm_configuration() {
    if [ "${ZBM_DETECTED}" != "true" ]; then
        return 0
    fi
    
    info "Backing up ZFSBootMenu configuration..."
    
    if [ -f "$ZBM_CONFIG" ]; then
        cp "$ZBM_CONFIG" "$BACKUP_DIR/zfsbootmenu-config.yaml" 2>/dev/null || true
    fi
    
    if [ -d "/etc/zfsbootmenu" ]; then
        cp -r "/etc/zfsbootmenu" "$BACKUP_DIR/zfsbootmenu-etc/" 2>/dev/null || true
    fi
    
    if [ -n "${ZBM_EFI_PATH}" ] && [ -f "$ZBM_EFI_PATH" ]; then
        cp "$ZBM_EFI_PATH" "$BACKUP_DIR/vmlinuz.efi.backup" 2>/dev/null || true
    fi
    
    if command -v efibootmgr >/dev/null 2>&1; then
        efibootmgr -v > "$BACKUP_DIR/efi-boot-entries.txt" 2>&1 || true
    fi
    
    success "ZFSBootMenu configuration backed up"
}

backup_esp_completely() {
    if [ "${ZBM_DETECTED}" != "true" ]; then
        return 0
    fi
    
    info "Creating complete ESP backup..."
    
    local esp_mount esp_backup_dir
    esp_mount=${ESP_MOUNT:-/boot/efi}
    
    if [ ! -d "$esp_mount" ]; then
        warning "ESP mount point not found: $esp_mount"
        return 0
    fi
    
    # Create ESP backup directory
    esp_backup_dir="$BACKUP_DIR/esp-complete-backup"
    mkdir -p "$esp_backup_dir"
    
    # Backup entire ESP structure
    if cp -r "$esp_mount"/* "$esp_backup_dir/" 2>/dev/null; then
        success "Complete ESP backup created"
    else
        warning "ESP backup may be incomplete"
    fi
    
    # Get partition information
    {
        echo "=== ESP Filesystem Info ==="
        df -h "$esp_mount" 2>/dev/null || true
        echo ""
        echo "=== ESP Mount Info ==="
        findmnt "$esp_mount" 2>/dev/null || true
        echo ""
        echo "=== ESP Contents ==="
        find "$esp_mount" -type f 2>/dev/null || true
    } > "$BACKUP_DIR/esp-info.txt"
    
    success "ESP information saved to esp-info.txt"
}

main() {
    header "ZFS PRE-UPDATE CHECKS"
    
    log "Starting ZFS pre-update checks..."
    
    check_root
    validate_dependencies
    create_initial_config
    
    # CRITICAL: Check for updates FIRST
    if ! check_available_updates; then
        # No updates available - clean exit
        exit 0
    fi
    
    # Updates available - continue with full checks
    header "UPDATES FOUND - PERFORMING SYSTEM CHECKS"
    
    check_system_resources
    check_zfs_loaded
    check_dracut_available 
    check_zfs_specific_updates
    detect_zfsbootmenu
    check_void_services
    check_system_versions
    check_pool_health
    check_zbm_boot_pool
    check_zbm_esp
    check_disk_space
    check_running_processes
    create_backups
    backup_zbm_configuration
    backup_esp_completely
    
    header "PRE-CHECKS COMPLETED SUCCESSFULLY"
    
    success "All pre-update checks passed!"
    log "System type: $([ "${ZBM_DETECTED}" = "true" ] && echo "ZFSBootMenu" || echo "Traditional")"
    log "Updates found: ${TOTAL_UPDATES} packages (ZFS: ${ZFS_COUNT}, ZBM: ${ZBM_COUNT}, Dracut: ${DRACUT_COUNT}, Kernel: ${KERNEL_COUNT}, Firmware: ${FIRMWARE_COUNT})"
    log "Backup directory: $BACKUP_DIR"
    log "Configuration saved to: $CONFIG_FILE"
    log "Ready to proceed with updates"
    
    echo ""
    echo "=========================================="
    echo -e "${GREEN}✓ PRE-CHECKS COMPLETED SUCCESSFULLY${NC}"
    echo "=========================================="
    echo "System type: $([ "${ZBM_DETECTED}" = "true" ] && echo "ZFSBootMenu" || echo "Traditional")"
    echo "Updates: ${TOTAL_UPDATES} packages (ZFS: ${ZFS_COUNT}, ZBM: ${ZBM_COUNT}, Dracut: ${DRACUT_COUNT}, Kernel: ${KERNEL_COUNT}, Firmware: ${FIRMWARE_COUNT})"
    echo "Backup: $BACKUP_DIR"
    echo "Log: $LOG_FILE"
    echo ""
    echo "Next step: Run zfs-install-updates.sh"
    echo "=========================================="
}

main "$@"
