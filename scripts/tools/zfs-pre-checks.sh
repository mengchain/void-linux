#!/bin/bash
# filepath: zfs-pre-checks.sh
# ZFS Pre-Update Checks for Void Linux with ZFSBootMenu Support
# This script checks for updates FIRST, then performs comprehensive system checks

set -euo pipefail

# Global configuration - these are intentionally global
readonly LOG_FILE="/var/log/zfs-pre-checks-$(date +%Y%m%d-%H%M%S).log"
readonly BACKUP_DIR="/var/backups/zfs-update-$(date +%Y%m%d-%H%M%S)"
readonly CONFIG_FILE="/etc/zfs-update.conf"
readonly SCRIPT_VERSION="1.2"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly NC='\033[0m'

log() {
    echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

success() {
    log "${GREEN}✓ $1${NC}"
}

warning() {
    log "${YELLOW}⚠ WARNING: $1${NC}"
}

error() {
    log "${RED}✗ ERROR: $1${NC}"
}

info() {
    log "${BLUE}ℹ INFO: $1${NC}"
}

header() {
    echo ""
    log "${BOLD}${CYAN}=========================================="
    log "$1"
    log "==========================================${NC}"
    echo ""
}

error_exit() {
    error "$1"
    log "Pre-checks failed. Fix issues before proceeding with updates."
    exit 1
}

check_root() {
    if [ "$EUID" -ne 0 ]; then
        error_exit "This script must be run as root"
    fi
}

validate_dependencies() {
    local deps="xbps-install xbps-query zpool zfs findmnt df grep awk sed mkdir cp bc modinfo lsmod"
    local missing_deps=""
    local cmd
    
    info "Validating system dependencies..."
    
    for cmd in $deps; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing_deps="$missing_deps $cmd"
        fi
    done
    
    if [ -n "$missing_deps" ]; then
        error_exit "Required commands not found:$missing_deps"
    fi
    
    success "All required dependencies available"
}

create_initial_config() {
    cat > "$CONFIG_FILE" << EOF
#!/bin/bash
# ZFS Update Configuration
# Generated by zfs-pre-checks.sh on $(date)
# This file can be sourced by other scripts

# Basic configuration
BACKUP_DIR="$BACKUP_DIR"
LOG_FILE="$LOG_FILE"
TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
SCRIPT_VERSION="$SCRIPT_VERSION"
VOID_LINUX=true

# System detection
ARCH="$(uname -m)"
KERNEL_VERSION="$(uname -r)"
HOSTNAME="$(hostname)"

# Will be populated by checks
UPDATES_AVAILABLE=false
ZFSBOOTMENU=false
POOLS_EXIST=false
EOF
    chmod 600 "$CONFIG_FILE"
}

check_available_updates() {
    local all_updates zfs_updates zbm_updates dracut_updates kernel_updates firmware_updates
    local zfs_count zbm_count dracut_count kernel_count firmware_count total_updates
    
    header "CHECKING FOR AVAILABLE UPDATES"
    
    info "Syncing package database..."
    if ! xbps-install -S >/dev/null 2>&1; then
        error_exit "Failed to sync package database. Check network connection."
    fi
    success "Package database synced"
    
    # Get all available updates first
    all_updates=$(xbps-install -un 2>/dev/null || true)
    
    # Check for ZFS-specific updates - Fixed regex for Void Linux package naming
    zfs_updates=$(echo "$all_updates" | grep -E "^zfs-[0-9]" || true)
    zfs_count=$(echo "$zfs_updates" | grep -c "^zfs-" 2>/dev/null || echo "0")
    
    # Check for ZFSBootMenu updates
    zbm_updates=$(echo "$all_updates" | grep -E "^zfsbootmenu-[0-9]" || true)
    zbm_count=$(echo "$zbm_updates" | grep -c "^zfsbootmenu-" 2>/dev/null || echo "0")
    
    # Check for dracut updates
    dracut_updates=$(echo "$all_updates" | grep -E "^dracut-[0-9]" || true)
    dracut_count=$(echo "$dracut_updates" | grep -c "^dracut-" 2>/dev/null || echo "0")
    
    # Void Linux kernel package naming: linux6.6, linux6.1, etc.
    kernel_updates=$(echo "$all_updates" | grep -E "^linux[0-9]+\.[0-9]+-[0-9]" || true)
    kernel_count=$(echo "$kernel_updates" | grep -c -E "^linux[0-9]+\.[0-9]+" 2>/dev/null || echo "0")
    
    # Check for firmware updates
    firmware_updates=$(echo "$all_updates" | grep -E "^linux-firmware-[0-9]" || true)
    firmware_count=$(echo "$firmware_updates" | grep -c "^linux-firmware-" 2>/dev/null || echo "0")
    
    # Calculate total relevant updates
    total_updates=$((zfs_count + zbm_count + dracut_count + kernel_count + firmware_count))
    
    # Log findings with improved detail
    info "Update availability results:"
    log "  ZFS updates: $zfs_count packages"
    log "  ZFSBootMenu updates: $zbm_count packages"
    log "  Dracut updates: $dracut_count packages"
    log "  Kernel updates: $kernel_count packages"
    log "  Firmware updates: $firmware_count packages"
    
    # Show detailed update information if available
    [ -n "$zfs_updates" ] && info "ZFS updates available:" && echo "$zfs_updates" | while IFS= read -r line; do [ -n "$line" ] && log "  $line"; done
    [ -n "$zbm_updates" ] && info "ZFSBootMenu updates available:" && echo "$zbm_updates" | while IFS= read -r line; do [ -n "$line" ] && log "  $line"; done
    [ -n "$dracut_updates" ] && info "Dracut updates available:" && echo "$dracut_updates" | while IFS= read -r line; do [ -n "$line" ] && log "  $line"; done
    [ -n "$kernel_updates" ] && info "Kernel updates available:" && echo "$kernel_updates" | while IFS= read -r line; do [ -n "$line" ] && log "  $line"; done
    [ -n "$firmware_updates" ] && info "Firmware updates available:" && echo "$firmware_updates" | while IFS= read -r line; do [ -n "$line" ] && log "  $line"; done
    
    if [ "$total_updates" -eq 0 ]; then
        header "NO UPDATES AVAILABLE"
        success "System is up to date for ZFS-related packages"
        info "You can run 'xbps-install -u' to check for other package updates"
        
        # Create minimal config for consistency
        {
            echo "UPDATES_AVAILABLE=false"
            echo "TOTAL_UPDATES=0"
            echo "ZFS_COUNT=0"
            echo "ZBM_COUNT=0"
            echo "DRACUT_COUNT=0"
            echo "KERNEL_COUNT=0"
            echo "FIRMWARE_COUNT=0"
        } >> "$CONFIG_FILE"
        
        return 1  # No updates needed
    else
        success "Found $total_updates ZFS/kernel/firmware/dracut updates"
        
        # Save update information to config - Make variables global for later use
        {
            echo "UPDATES_AVAILABLE=true"
            echo "TOTAL_UPDATES=$total_updates"
            echo "ZFS_COUNT=$zfs_count"
            echo "ZBM_COUNT=$zbm_count"
            echo "DRACUT_COUNT=$dracut_count"
            echo "KERNEL_COUNT=$kernel_count"
            echo "FIRMWARE_COUNT=$firmware_count"
        } >> "$CONFIG_FILE"
        
        # Export for use in summary
        export TOTAL_UPDATES="$total_updates"
        export ZFS_COUNT="$zfs_count"
        export ZBM_COUNT="$zbm_count"
        export DRACUT_COUNT="$dracut_count"
        export KERNEL_COUNT="$kernel_count"
        export FIRMWARE_COUNT="$firmware_count"
        
        return 0  # Updates available
    fi
}

check_zfs_loaded() {
    local zfs_loaded zpool_available zfs_available
    
    info "Checking ZFS module status..."
    
    zfs_loaded=$(lsmod | grep -c "^zfs " || echo "0")
    if [ "$zfs_loaded" -eq 0 ]; then
        error_exit "ZFS module is not loaded. Load it with: modprobe zfs"
    fi
    
    if ! command -v zpool >/dev/null 2>&1; then
        error_exit "zpool command not found. Install zfs package."
    fi
    
    if ! command -v zfs >/dev/null 2>&1; then
        error_exit "zfs command not found. Install zfs package."
    fi
    
    success "ZFS module and tools are available"
}

check_dracut_available() {
    local dracut_modules_dir zfs_module_found
    
    info "Checking dracut availability..."
    
    if ! command -v dracut >/dev/null 2>&1; then
        error_exit "dracut command not found. Install dracut package."
    fi
    
    # Check dracut configuration
    if [ ! -f /etc/dracut.conf ] && [ ! -d /etc/dracut.conf.d ]; then
        warning "No dracut configuration found. Default settings will be used."
    fi
    
    # Check for ZFS module in dracut - Void Linux specific paths
    zfs_module_found=false
    for dracut_modules_dir in "/usr/lib/dracut/modules.d" "/usr/share/dracut/modules.d"; do
        if [ -d "$dracut_modules_dir/90zfs" ]; then
            zfs_module_found=true
            info "Found dracut ZFS module in $dracut_modules_dir/90zfs"
            break
        fi
    done
    
    if [ "$zfs_module_found" = "false" ]; then
        error_exit "dracut ZFS module not found. Ensure zfs package is properly installed."
    fi
    
    # Test if dracut can list ZFS module
    if dracut --list-modules 2>/dev/null | grep -q "^zfs$"; then
        success "dracut ZFS module is available and detectable"
    else
        warning "dracut may not detect ZFS module properly - this might be normal"
    fi
    
    success "dracut is available with ZFS support"
}

check_void_services() {
    local active_services service service_name critical_services
    
    info "Checking Void Linux specific services..."
    
    # Services that should generally be left running during updates
    critical_services="sshd chronyd dbus dhcpcd wpa_supplicant NetworkManager"
    
    if command -v sv >/dev/null 2>&1; then
        # Get list of running services
        active_services=$(sv status /var/service/* 2>/dev/null | grep "^run:" | awk '{print $2}' || true)
        
        if [ -n "$active_services" ]; then
            info "Active runit services detected:"
            for service in $active_services; do
                service_name=$(basename "$service")
                
                # Check if it's a critical service
                if echo "$critical_services" | grep -q "$service_name"; then
                    log "  ✓ $service_name (critical - keep running)"
                else
                    log "  ○ $service_name"
                fi
            done
        else
            info "No active services detected via runit"
        fi
    else
        warning "runit service manager (sv) not found"
    fi
    
    success "Void services check completed"
}

check_zfs_specific_updates() {
    local zfs_packages pkg zfs_specific_updates zfs_specific_count
    local installed_pkg
    
    info "Checking ZFS-specific package updates..."
    
    # Void Linux ZFS-related packages
    zfs_packages="zfs zfsbootmenu dracut"
    zfs_specific_updates=""
    zfs_specific_count=0
    
    for pkg in $zfs_packages; do
        # Check if package is installed first
        if xbps-query -l | grep -q "^ii $pkg-"; then
            # Check if update is available
            if xbps-install -un 2>/dev/null | grep -q "^${pkg}-"; then
                zfs_specific_updates="$zfs_specific_updates $pkg"
                zfs_specific_count=$((zfs_specific_count + 1))
            fi
        fi
    done
    
    if [ -n "$zfs_specific_updates" ]; then
        info "ZFS-related packages with updates:$zfs_specific_updates"
        echo "ZFS_SPECIFIC_UPDATES=\"$zfs_specific_updates\"" >> "$CONFIG_FILE"
        echo "ZFS_SPECIFIC_COUNT=$zfs_specific_count" >> "$CONFIG_FILE"
        return 0
    else
        info "No ZFS-specific package updates found"
        echo "ZFS_SPECIFIC_UPDATES=\"\"" >> "$CONFIG_FILE"
        echo "ZFS_SPECIFIC_COUNT=0" >> "$CONFIG_FILE"
        return 1
    fi
}

detect_zfsbootmenu() {
    local zbm_detected zbm_config zbm_config_paths config_path zbm_version
    
    info "Detecting boot method..."
    
    zbm_detected=false
    zbm_config=""
    
    # ZFSBootMenu config locations per official documentation
    zbm_config_paths="/etc/zfsbootmenu/config.yaml /etc/zfsbootmenu.yaml"
    
    for config_path in $zbm_config_paths; do
        if [ -f "$config_path" ]; then
            zbm_config="$config_path"
            zbm_detected=true
            info "ZFSBootMenu configuration found: $zbm_config"
            echo "ZBM_CONFIG=\"$zbm_config\"" >> "$CONFIG_FILE"
            break
        fi
    done
    
    # Check EFI boot entries
    if command -v efibootmgr >/dev/null 2>&1; then
        if efibootmgr 2>/dev/null | grep -qi "zfsbootmenu\|zbm"; then
            zbm_detected=true
            info "ZFSBootMenu found in EFI boot entries"
        fi
    fi
    
    # Check current boot parameters
    if [ -f /proc/cmdline ] && grep -q "zfsbootmenu" /proc/cmdline 2>/dev/null; then
        zbm_detected=true
        info "ZFSBootMenu detected in current boot parameters"
    fi
    
    # Check for ZFSBootMenu command
    if command -v zfsbootmenu >/dev/null 2>&1; then
        zbm_detected=true
        zbm_version=$(zfsbootmenu --version 2>/dev/null | head -1 || echo "unknown")
        info "ZFSBootMenu command available, version: $zbm_version"
        echo "ZBM_VERSION=\"$zbm_version\"" >> "$CONFIG_FILE"
    fi
    
    # Check for generate-zbm command (common ZBM tool)
    if command -v generate-zbm >/dev/null 2>&1; then
        zbm_detected=true
        info "generate-zbm command found"
    fi
    
    if [ "$zbm_detected" = true ]; then
        success "ZFSBootMenu system detected"
        echo "ZFSBOOTMENU=true" >> "$CONFIG_FILE"
        export ZBM_DETECTED="true"
        export ZBM_CONFIG="$zbm_config"
    else
        info "Traditional bootloader system (GRUB/systemd-boot)"
        echo "ZFSBOOTMENU=false" >> "$CONFIG_FILE"
        export ZBM_DETECTED="false"
    fi
}

check_system_versions() {
    local current_kernel current_zfs zfs_userland dracut_version
    local zfs_kmod_version
    
    info "Checking current system versions..."
    
    current_kernel=$(uname -r)
    
    # Get ZFS kernel module version more reliably
    if current_zfs=$(modinfo zfs 2>/dev/null | awk '/^version:/ {print $2}'); then
        [ -z "$current_zfs" ] && current_zfs="unknown"
    else
        current_zfs="unknown"
    fi
    
    # Get ZFS userland version
    if zfs_userland=$(zfs version 2>/dev/null | head -1 | awk '{print $2}'); then
        [ -z "$zfs_userland" ] && zfs_userland="unknown"
    else
        zfs_userland="unknown"
    fi
    
    # Get dracut version
    if dracut_version=$(dracut --version 2>/dev/null | head -1 | awk '{print $NF}'); then
        [ -z "$dracut_version" ] && dracut_version="unknown"
    else
        dracut_version="unknown"
    fi
    
    log "Current kernel: $current_kernel"
    log "ZFS kernel module: $current_zfs"
    log "ZFS userland: $zfs_userland"
    log "Dracut version: $dracut_version"
    
    # Check for version mismatch
    if [ "$current_zfs" != "unknown" ] && [ "$zfs_userland" != "unknown" ]; then
        if [ "$current_zfs" != "$zfs_userland" ]; then
            warning "ZFS kernel module ($current_zfs) and userland ($zfs_userland) versions differ"
            warning "This is normal if updates are available"
        else
            success "ZFS kernel and userland versions match"
        fi
    fi
    
    # Save version info
    {
        echo "CURRENT_KERNEL=\"$current_kernel\""
        echo "CURRENT_ZFS=\"$current_zfs\""
        echo "ZFS_USERLAND=\"$zfs_userland\""
        echo "DRACUT_VERSION=\"$dracut_version\""
    } >> "$CONFIG_FILE"
}

check_pool_health() {
    local pool_list pool_status pools_exist
    
    info "Checking ZFS pool health..."
    
    if ! zpool list >/dev/null 2>&1; then
        warning "No ZFS pools found"
        echo "POOLS_EXIST=false" >> "$CONFIG_FILE"
        export POOLS_EXIST="false"
        return 0
    fi
    
    pools_exist="true"
    echo "POOLS_EXIST=true" >> "$CONFIG_FILE"
    export POOLS_EXIST="true"
    
    info "Current pool status:"
    zpool status -v | tee -a "$LOG_FILE"
    
    # Check for pool errors
    pool_status=$(zpool status)
    if echo "$pool_status" | grep -E "(DEGRADED|FAULTED|OFFLINE|UNAVAIL)" >/dev/null; then
        error_exit "ZFS pools have errors. Fix pool issues before updating."
    fi
    
    if echo "$pool_status" | grep -q "scrub in progress"; then
        error_exit "ZFS scrub is in progress. Wait for completion before updating."
    fi
    
    if echo "$pool_status" | grep -q "resilver in progress"; then
        error_exit "ZFS resilver is in progress. Wait for completion before updating."
    fi
    
    success "All ZFS pools are healthy"
}

check_zbm_boot_pool() {
    local boot_pools
    
    if [ "${ZBM_DETECTED:-false}" != "true" ]; then
        return 0
    fi
    
    info "Checking ZFSBootMenu boot pool configuration..."
    
    # Find boot pools - common naming conventions
    boot_pools=$(zpool list -H -o name 2>/dev/null | grep -E "(bpool|boot|rpool)" || true)
    
    # Try to detect from ZBM config if available
    if [ -z "$boot_pools" ] && [ -n "${ZBM_CONFIG:-}" ] && [ -f "$ZBM_CONFIG" ]; then
        boot_pools=$(grep -E "pool:" "$ZBM_CONFIG" 2>/dev/null | grep -v "^#" | awk -F: '{print $2}' | tr -d ' "' || true)
    fi
    
    # If still no pools found, check for any pools (ZBM can work with any pool)
    if [ -z "$boot_pools" ]; then
        boot_pools=$(zpool list -H -o name 2>/dev/null | head -1 || true)
        if [ -n "$boot_pools" ]; then
            info "Using primary pool for ZFSBootMenu: $boot_pools"
        fi
    fi
    
    if [ -n "$boot_pools" ]; then
        info "Boot pool(s) detected: $boot_pools"
        echo "BOOT_POOLS=\"$boot_pools\"" >> "$CONFIG_FILE"
        
        # Check each pool's health
        for pool in $boot_pools; do
            if ! zpool status "$pool" | grep -q "state: ONLINE"; then
                error_exit "Boot pool $pool is not ONLINE. Fix before updating."
            fi
        done
        
        success "Boot pool(s) are healthy"
    else
        warning "No ZFS pools found for ZFSBootMenu"
        echo "BOOT_POOLS=\"\"" >> "$CONFIG_FILE"
    fi
}

check_zbm_esp() {
    local esp_candidates esp_mount esp_path esp_usage esp_free_mb zbm_efi_path
    
    if [ "${ZBM_DETECTED:-false}" != "true" ]; then
        return 0
    fi
    
    info "Checking EFI System Partition for ZFSBootMenu..."
    
    # Common ESP mount points in Void Linux
    esp_candidates="/boot/efi /efi /boot"
    esp_mount=""
    
    # Find mounted vfat filesystem (ESP)
    for esp_path in $esp_candidates; do
        if [ -d "$esp_path" ] && findmnt -t vfat "$esp_path" >/dev/null 2>&1; then
            esp_mount="$esp_path"
            info "Found ESP mounted at: $esp_mount"
            break
        fi
    done
    
    # If not found in common locations, try to find any vfat mount
    if [ -z "$esp_mount" ]; then
        esp_mount=$(findmnt -n -o TARGET -t vfat 2>/dev/null | head -1 || true)
        if [ -n "$esp_mount" ]; then
            info "Found ESP at: $esp_mount"
        fi
    fi
    
    if [ -z "$esp_mount" ] || [ ! -d "$esp_mount" ]; then
        error_exit "EFI System Partition not found. ZFSBootMenu requires ESP."
    fi
    
    # Check ESP space usage
    esp_usage=$(df "$esp_mount" | awk 'NR==2 {print $5}' | sed 's/%//' || echo "0")
    esp_free_mb=$(df -m "$esp_mount" | awk 'NR==2 {print $4}' || echo "0")
    
    if [ "$esp_usage" -gt 80 ]; then
        warning "EFI System Partition is ${esp_usage}% full"
    fi
    
    if [ "$esp_free_mb" -lt 50 ]; then
        error_exit "EFI System Partition has less than 50MB free space"
    fi
    
    # Look for ZBM EFI files in common locations
    zbm_efi_path=""
    for zbm_path in "$esp_mount/EFI/zbm/vmlinuz.efi" "$esp_mount/EFI/ZBM/vmlinuz.efi" "$esp_mount/vmlinuz.efi"; do
        if [ -f "$zbm_path" ]; then
            zbm_efi_path="$zbm_path"
            success "ZFSBootMenu EFI image found: $zbm_efi_path"
            echo "ZBM_EFI_PATH=\"$zbm_efi_path\"" >> "$CONFIG_FILE"
            break
        fi
    done
    
    if [ -z "$zbm_efi_path" ]; then
        warning "ZFSBootMenu EFI image not found in expected locations"
    fi
    
    # Save ESP information
    {
        echo "ESP_MOUNT=\"$esp_mount\""
        echo "ESP_USAGE=$esp_usage"
        echo "ESP_FREE_MB=$esp_free_mb"
    } >> "$CONFIG_FILE"
    
    export ESP_MOUNT="$esp_mount"
    
    success "ESP check completed (${esp_usage}% used, ${esp_free_mb}MB free)"
}

check_system_resources() {
    local available_mem_kb available_mem_mb total_mem_kb load_avg
    
    info "Checking system resources..."
    
    # Check available memory (ZFS needs sufficient RAM)
    available_mem_kb=$(awk '/MemAvailable/ {print $2}' /proc/meminfo 2>/dev/null || echo "0")
    available_mem_mb=$((available_mem_kb / 1024))
    
    total_mem_kb=$(awk '/MemTotal/ {print $2}' /proc/meminfo 2>/dev/null || echo "0")
    
    log "Available memory: ${available_mem_mb}MB"
    
    if [ "$available_mem_mb" -lt 512 ]; then
        warning "Less than 512MB RAM available. ZFS updates may be slow."
    fi
    
    # Check system load
    load_avg=$(awk '{print $1}' /proc/loadavg 2>/dev/null || echo "0.0")
    
    # Use awk for floating point comparison instead of bc
    if awk "BEGIN {exit !($load_avg > 2.0)}"; then
        warning "High system load detected: $load_avg"
        warning "Consider waiting for load to decrease before updating"
    fi
    
    log "System load average: $load_avg"
    
    success "System resources check completed"
}

check_disk_space() {
    local root_usage root_free_mb boot_usage boot_free_mb backup_free_mb
    
    info "Checking disk space..."
    
    # Check root filesystem space
    root_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//' || echo "0")
    root_free_mb=$(df -m / | awk 'NR==2 {print $4}' || echo "0")
    
    if [ "$root_usage" -gt 90 ]; then
        error_exit "Root filesystem is ${root_usage}% full. Need space for updates."
    fi
    
    log "Root filesystem: ${root_usage}% used, ${root_free_mb}MB free"
    
    # Check /boot if it's a separate mount point
    if mountpoint -q /boot 2>/dev/null; then
        boot_usage=$(df /boot | awk 'NR==2 {print $5}' | sed 's/%//' || echo "0")
        boot_free_mb=$(df -m /boot | awk 'NR==2 {print $4}' || echo "0")
        
        log "Boot filesystem: ${boot_usage}% used, ${boot_free_mb}MB free"
        
        if [ "$boot_usage" -gt 80 ]; then
            warning "Boot partition is ${boot_usage}% full"
        fi
        
        if [ "$boot_free_mb" -lt 100 ]; then
            error_exit "Boot partition needs at least 100MB free space"
        fi
    fi
    
    # Check space for backups
    backup_free_mb=$(df -m "$(dirname "$BACKUP_DIR")" | awk 'NR==2 {print $4}' || echo "0")
    if [ "$backup_free_mb" -lt 1024 ]; then
        warning "Less than 1GB available for backups in $(dirname "$BACKUP_DIR")"
    fi
    
    success "Sufficient disk space available"
}

check_running_processes() {
    local process_warnings
    
    info "Checking for potentially interfering processes..."
    
    process_warnings=0
    
    # Check for database processes that might be using ZFS datasets
    if pgrep -f "(mysqld|postgresql|mongodb|mariadb)" >/dev/null 2>&1; then
        warning "Database processes detected - consider stopping before update"
        process_warnings=$((process_warnings + 1))
    fi
    
    # Check for backup processes
    if pgrep -f "(rsync|borgbackup|duplicity|tar)" >/dev/null 2>&1; then
        warning "Backup processes detected - consider waiting for completion"
        process_warnings=$((process_warnings + 1))
    fi
    
    # Check for package manager processes
    if pgrep -f "xbps-install" >/dev/null 2>&1; then
        error_exit "Another xbps-install process is running. Wait for completion."
    fi
    
    # Check for ZFS maintenance processes
    if pgrep -f "(zfs send|zfs receive|zpool scrub)" >/dev/null 2>&1; then
        warning "ZFS maintenance processes detected"
        process_warnings=$((process_warnings + 1))
    fi
    
    if [ "$process_warnings" -eq 0 ]; then
        success "No interfering processes detected"
    else
        success "Process check completed with $process_warnings warnings"
    fi
}

create_backups() {
    info "Creating backup directory and configurations..."
    
    # Create backup directory with proper permissions
    if ! mkdir -p "$BACKUP_DIR"; then
        error_exit "Failed to create backup directory: $BACKUP_DIR"
    fi
    
    # Backup ZFS configurations if pools exist
    if [ "${POOLS_EXIST:-false}" = "true" ]; then
        info "Backing up ZFS configurations..."
        
        # Create ZFS configuration backups with error handling
        {
            zfs list -H -o name,mountpoint > "$BACKUP_DIR/zfs-datasets.txt" || true
            zpool list -H > "$BACKUP_DIR/zpool-list.txt" || true
            zfs get all > "$BACKUP_DIR/zfs-properties.txt" || true
            zpool get all > "$BACKUP_DIR/zpool-properties.txt" || true
            zfs list -t snapshot > "$BACKUP_DIR/zfs-snapshots.txt" 2>/dev/null || true
            # Export ZFS pool configurations
            zdb -e > "$BACKUP_DIR/zfs-pool-configs.txt" 2>/dev/null || true
        }
    fi
    
    # Backup system configuration files
    [ -f /etc/fstab ] && cp /etc/fstab "$BACKUP_DIR/" 2>/dev/null || true
    [ -f /etc/dracut.conf ] && cp /etc/dracut.conf "$BACKUP_DIR/" 2>/dev/null || true
    [ -d /etc/dracut.conf.d ] && cp -r /etc/dracut.conf.d "$BACKUP_DIR/dracut.conf.d-backup/" 2>/dev/null || true
    [ -d /boot/grub ] && cp -r /boot/grub "$BACKUP_DIR/grub-backup/" 2>/dev/null || true
    
    # Backup modprobe configurations
    if [ -d /etc/modprobe.d ]; then
        mkdir -p "$BACKUP_DIR/modprobe.d-backup"
        cp /etc/modprobe.d/*.conf "$BACKUP_DIR/modprobe.d-backup/" 2>/dev/null || true
    fi
    
    # Backup current kernel modules list
    lsmod > "$BACKUP_DIR/current-modules.txt" 2>/dev/null || true
    
    success "System configuration backup created in $BACKUP_DIR"
}

backup_zbm_configuration() {
    if [ "${ZBM_DETECTED:-false}" != "true" ]; then
        return 0
    fi
    
    info "Backing up ZFSBootMenu configuration..."
    
    # Backup ZBM config file
    if [ -n "${ZBM_CONFIG:-}" ] && [ -f "$ZBM_CONFIG" ]; then
        cp "$ZBM_CONFIG" "$BACKUP_DIR/zfsbootmenu-config.yaml" || warning "Failed to backup ZBM config"
    fi
    
    # Backup entire ZBM configuration directory
    if [ -d "/etc/zfsbootmenu" ]; then
        cp -r "/etc/zfsbootmenu" "$BACKUP_DIR/zfsbootmenu-etc-backup/" 2>/dev/null || true
    fi
    
    # Backup ZBM EFI image if found
    if [ -n "${ZBM_EFI_PATH:-}" ] && [ -f "${ZBM_EFI_PATH}" ]; then
        cp "${ZBM_EFI_PATH}" "$BACKUP_DIR/vmlinuz.efi.backup" || warning "Failed to backup ZBM EFI image"
    fi
    
    # Backup EFI boot entries
    if command -v efibootmgr >/dev/null 2>&1; then
        efibootmgr -v > "$BACKUP_DIR/efi-boot-entries.txt" 2>&1 || true
    fi
    
    success "ZFSBootMenu configuration backed up"
}

backup_esp_completely() {
    local esp_backup_dir
    
    if [ "${ZBM_DETECTED:-false}" != "true" ]; then
        return 0
    fi
    
    info "Creating complete ESP backup..."
    
    if [ -z "${ESP_MOUNT:-}" ] || [ ! -d "${ESP_MOUNT}" ]; then
        warning "ESP mount point not available for backup"
        return 0
    fi
    
    # Create ESP backup directory
    esp_backup_dir="$BACKUP_DIR/esp-complete-backup"
    mkdir -p "$esp_backup_dir"
    
    # Backup entire ESP structure
    if cp -r "${ESP_MOUNT}"/* "$esp_backup_dir/" 2>/dev/null; then
        success "Complete ESP backup created"
    else
        warning "ESP backup may be incomplete - some files may be inaccessible"
    fi
    
    # Create detailed ESP information file
    {
        echo "=== ESP Backup Information ==="
        echo "Backup Date: $(date)"
        echo "ESP Mount Point: ${ESP_MOUNT}"
        echo ""
        echo "=== ESP Filesystem Info ==="
        df -h "${ESP_MOUNT}" 2>/dev/null || echo "Unable to get filesystem info"
        echo ""
        echo "=== ESP Mount Info ==="
        findmnt "${ESP_MOUNT}" 2>/dev/null || echo "Unable to get mount info"
        echo ""
        echo "=== ESP Directory Structure ==="
        find "${ESP_MOUNT}" -type d 2>/dev/null | sort || echo "Unable to list directories"
        echo ""
        echo "=== ESP Files ==="
        find "${ESP_MOUNT}" -type f 2>/dev/null | sort || echo "Unable to list files"
    } > "$BACKUP_DIR/esp-backup-info.txt"
    
    success "ESP backup and information saved"
}

main() {
    local exit_code=0
    
    header "ZFS PRE-UPDATE CHECKS FOR VOID LINUX"
    log "Starting ZFS pre-update checks..."
    log "Script version: $SCRIPT_VERSION"
    
    # Basic system validation
    check_root
    validate_dependencies
    create_initial_config
    
    # CRITICAL: Check for updates FIRST
    if ! check_available_updates; then
        header "NO UPDATES AVAILABLE"
        info "System is up to date. No further checks needed."
        exit 0
    fi
    
    # Updates available - continue with full system checks
    header "UPDATES FOUND - PERFORMING COMPREHENSIVE SYSTEM CHECKS"
    
    # System resource and compatibility checks
    check_system_resources
    check_zfs_loaded
    check_dracut_available
    check_zfs_specific_updates
    
    # Boot system detection and checks
    detect_zfsbootmenu
    check_void_services
    check_system_versions
    
    # ZFS pool and storage checks
    check_pool_health
    check_zbm_boot_pool
    check_zbm_esp
    check_disk_space
    
    # Process and safety checks
    check_running_processes
    
    # Create comprehensive backups
    create_backups
    backup_zbm_configuration
    backup_esp_completely
    
    header "PRE-CHECKS COMPLETED SUCCESSFULLY"
    
    # Final summary
    success "All pre-update checks passed!"
    log "System type: $([ "${ZBM_DETECTED:-false}" = "true" ] && echo "ZFSBootMenu" || echo "Traditional bootloader")"
    log "Updates found: ${TOTAL_UPDATES:-0} packages (ZFS: ${ZFS_COUNT:-0}, ZBM: ${ZBM_COUNT:-0}, Dracut: ${DRACUT_COUNT:-0}, Kernel: ${KERNEL_COUNT:-0}, Firmware: ${FIRMWARE_COUNT:-0})"
    log "Backup directory: $BACKUP_DIR"
    log "Configuration file: $CONFIG_FILE"
    log "Log file: $LOG_FILE"
    
    echo ""
    echo "=========================================="
    echo -e "${GREEN}✓ PRE-CHECKS COMPLETED SUCCESSFULLY${NC}"
    echo "=========================================="
    echo "System type: $([ "${ZBM_DETECTED:-false}" = "true" ] && echo "ZFSBootMenu" || echo "Traditional")"
    echo "Updates: ${TOTAL_UPDATES:-0} packages (ZFS: ${ZFS_COUNT:-0}, ZBM: ${ZBM_COUNT:-0}, Dracut: ${DRACUT_COUNT:-0}, Kernel: ${KERNEL_COUNT:-0}, Firmware: ${FIRMWARE_COUNT:-0})"
    echo "Backup: $BACKUP_DIR"
    echo "Log: $LOG_FILE"
    echo ""
    echo "✓ System is ready for ZFS updates"
    echo "Next step: Run your ZFS update script"
    echo "=========================================="
}

# Execute main function with all arguments
main "$@"
